/*******************************************************************************
 * Copyright (c) 2016 Avaloq Evolution AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Evolution AG - initial API and implementation
 *******************************************************************************/
import com::avaloq::tools::ddk::xtext::scope::scope;
import com::avaloq::tools::ddk::xtext::expression::expression;
import com::avaloq::tools::ddk::xtext::generator::expression; // for CompilationContext
import org::eclipse::emf::ecore; // for EObject

import org::eclipse::xtext; // for Grammar

extension org::eclipse::xtext::GrammarUtil;
extension org::eclipse::xtext::generator::Naming; // for toSimpleName
extension com::avaloq::tools::ddk::xtext::generator::expression::ExpressionExtensions;
extension com::avaloq::tools::ddk::xtext::generator::util::GenModelUtil2; // for instanceClassName

extension com::avaloq::tools::ddk::xtext::generator::util::GeneratorUtil;
extension com::avaloq::tools::ddk::xtext::generator::expression::CodeGeneration;

/*
 * CODE GENERATION
 */
getScopeProvider(Grammar grammar) :
    grammar.name.toJavaPackage() + ".scoping." + grammar.name.toSimpleName() + "ScopeProvider";

getScopeNameProvider(Grammar grammar) :
    grammar.name.toJavaPackage() + ".scoping." + grammar.name.toSimpleName() + "ScopeNameProvider";

// returns the name of the scope method generated for the given scope definition
String scopeMethodName(ScopeDefinition this) :
    getScopeName() + '_' + (targetType != null ? targetType.EPackage.name + '_' + targetType.name : contextType.EPackage.name + '_' + contextType.name + '_' + reference.name)
;

cached CompilationContext compilationContext(ScopeModel this) :
    JAVA com.avaloq.tools.ddk.xtext.scope.generator.ScopingGeneratorUtil.getCompilationContext(com.avaloq.tools.ddk.xtext.scope.scope.ScopeModel)
;

String locatorString(EObject this) :
    location().split('/').last().javaEncode()
;

String calledFeature(FeatureCall this) :
    type.id.first()
;

EStructuralFeature feature(FeatureCall this) :
    scopeType().getEStructuralFeature(calledFeature())
;

/*
 * SCOPE RULES
 */
List[ScopeRule] allScopeRules(Void this) : {};

List[ScopeRule] allScopeRules(ScopeDefinition this) :
  getModel().collectAllScopeRules(this)
;

private List[ScopeRule] collectAllScopeRules(ScopeModel this, ScopeDefinition def) :
    let d = scopes.select(d|d.isEqual(def)) :
    let myScopeRules = d == null ? {} : d.rules :
        (includedScopes.isEmpty
            ? {}
            : includedScopes.collectAllScopeRules(def).flatten()
        ).addAll(myScopeRules)
;

List[ScopeRule] sortedRules(Collection[ScopeRule] this) :
  JAVA com.avaloq.tools.ddk.xtext.scope.generator.ScopingGeneratorUtil.sortedRules(java.util.Collection)
;

Set[ScopeRule] filterUniqueRules(List[ScopeRule] this) :
    collect(r|selectFirst(r2|r2.hasSameContext(r))).toSet()
;

Boolean isEqual(ScopeRule a, ScopeRule b) :
    a.hasSameContext(b)
//  && ((a.name == null) == (b.name == null)) && (a.name == null || a.name.matches (b.name))
    && a.^context.guard.serialize() == b.^context.guard.serialize()
;

Boolean hasSameContext(ScopeRule a, ScopeRule b) :
    a.ruleSignature() == b.ruleSignature()
;

// Hrmph. Use naming here, otherwise we'll get strange (and wrong) results in the GenerateAllAPSLs workflow for netwStruct?!
private cached String ruleSignature(ScopeRule s) :
    JAVA com.avaloq.tools.ddk.xtext.scope.ScopeUtil.getSignature(com.avaloq.tools.ddk.xtext.scope.scope.ScopeRule)
;

/*
 * SCOPE DEFINITIONS
 */
// returns the list of all local and inherited scope definition (skipping any shadowed or extended scope definitions)
List[ScopeDefinition] allScopes(ScopeModel this) :
    (let myScopes = this.scopes :
        (this.includedScopes.isEmpty ? {} : this.includedScopes.allScopes()).reject(s|myScopes.hasScope(s)).addAll(myScopes)
    )
;

List[ScopeDefinition] allScopes(Void this) : {};

String getScopeName(ScopeDefinition this) :
    this.name == null ? 'scope' : this.name
;

Boolean hasScope(List[ScopeDefinition] list, ScopeDefinition scope) :
    list.isEmpty ? false : !(list.select(s|s.isEqual(scope)).isEmpty)
;

Boolean isEqual(ScopeDefinition a, ScopeDefinition b) :
    a.getScopeName() == b.getScopeName() && a.targetType.isEqual(b.targetType) && a.reference.isEqual(b.reference)
;

/*
 * SCOPE TYPE
 */
EClass scopeType(ScopeDefinition this) :
    reference != null ? reference.EReferenceType : targetType
;

EClass scopeType(ScopeRule this) :
    getScope().scopeType()
;

EClass scopeType(Expression this) :
    getScope() != null ? getScope().scopeType() : getNamingDef().type
;

ENamedElement typeOrRef(ScopeDefinition this) :
  reference != null ? reference : targetType
;

EReference contextRef(ScopeRule this) :
    this.getScope().reference
;

/*
 * Injections
 */
// returns the list of all local and inherited injections (skipping any shadowed injections)
List[Injection] allInjections(ScopeModel this) :
    (let myInjections = this.injections :
        (this.includedScopes.isEmpty ? {} : this.includedScopes.allInjections()).reject(i|myInjections.hasInjection(i)).addAll(myInjections)
    )
;

List[Injection] allInjections(Void this) : {};

Boolean hasInjection(List[Injection] list, Injection injection) :
    list.isEmpty ? false : !(list.select(i|i.isEqual(injection)).isEmpty)
;

Boolean isEqual(Injection a, Injection b) :
    a.type == b.type && a.name.isEqual(b.name)
;

/*
 * SCOPE EXPRESSIONS
 */
Boolean isCaseInsensitive(NamedScopeExpression this) :
    JAVA com.avaloq.tools.ddk.xtext.scope.generator.ScopingGeneratorUtil.isCaseInsensitive(com.avaloq.tools.ddk.xtext.scope.scope.NamedScopeExpression)
;

/*
 * ECONTAINER
 */
ScopeModel getModel(EObject this) :
    this.eResource().contents.first()
;

cached ScopeDefinition getScope(EObject this) :
    ((ScopeDefinition) eContainer(ScopeDefinition))
;

cached NamingDefinition getNamingDef(EObject this) :
    ((NamingDefinition) eContainer(NamingDefinition))
;

EObject eContainer(EObject this, xpand2::Type type) :
    type.isInstance(this) ? this : eContainer().eContainer(type)
;

EObject eContainer(Void this, xpand2::Type type) : null;

/*
 * ECORE
 */
Boolean isEqual(EClass a, EClass b) :
    a == b || (a != null && b != null && a.name == b.name && a.EPackage.nsURI == b.EPackage.nsURI)
;

Boolean isEqual(Void a, Void b) :
    true
;

Boolean isEqual(EReference a, EReference b) :
    a == b || (a != null && b != null && a.name == b.name && a.EContainingClass.isEqual(b.EContainingClass))
;

/*
 * TESTING
 */
String scopeTestMethodName(ScopeRule this) :
  scopeTestMethodNamePrefix() + '_' + (this.^context.global ? 'Resource' : this.^context.contextType.instanceClassSimpleName())
;

private String scopeTestMethodNamePrefix(ScopeRule this) :
    let ref = contextRef() :
        ref != null ?
            getScope().getScopeName() + '_' + ref.EContainingClass.EPackage.name + '_' + ref.EContainingClass.name + '_' + ref.name
          : getScope().getScopeName() + '_' + scopeType().EPackage.name + '_' + scopeType().name
;

cached Set[CrossReference] allCrossReferences(Grammar this) :
  this.rules.containedAbstractElements().select(e|CrossReference.isInstance(e))
;

String linkingTestMethodName(CrossReference this) :
  'link_' + containingRule().name + '_' + getUniqueFeatureName()
;

private String getUniqueFeatureName(CrossReference this) :
  JAVA com.avaloq.tools.ddk.xtext.scope.generator.ScopingGeneratorUtil.getUniqueFeatureName(org.eclipse.xtext.CrossReference)
;
