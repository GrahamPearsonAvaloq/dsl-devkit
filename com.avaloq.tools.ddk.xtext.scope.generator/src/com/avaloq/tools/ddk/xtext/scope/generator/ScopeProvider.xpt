«IMPORT org::eclipse::xtext»
«IMPORT com::avaloq::tools::ddk::xtext::scope::scope»
«IMPORT com::avaloq::tools::ddk::xtext::expression::expression»
«IMPORT com::avaloq::tools::ddk::xtext::generator::expression»
«IMPORT org::eclipse::emf::ecore»

«EXTENSION com::avaloq::tools::ddk::xtext::generator::expression::CodeGeneration»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::expression::ExpressionExtensions»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::util::GeneratorUtil»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::util::GenModelUtil2»
«EXTENSION org::eclipse::xtext::generator::Naming»

«EXTENSION com::avaloq::tools::ddk::xtext::scope::generator::ScopeProvider»
«REM»
  context instanceof «r.context.contextType.instanceClassName()» APPEARS TO BE SLOWER THAN
  «r.context.contextType.literalIdentifier()».isSuperTypeOf(context.eClass())
«ENDREM»

«DEFINE generate(ScopeModel model) FOR Grammar»
«FILE getScopeProvider().asPath()+".java" SRC_GEN -»
package «getScopeProvider().toJavaPackage()»;

import org.apache.log4j.Logger;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;

import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.scoping.IScope;

import com.avaloq.tools.ddk.xtext.scoping.AbstractNameFunction;
import com.avaloq.tools.ddk.xtext.scoping.AbstractPolymorphicScopeProvider;
import com.avaloq.tools.ddk.xtext.scoping.IContextSupplier;
import com.avaloq.tools.ddk.xtext.scoping.INameFunction;
import com.avaloq.tools.ddk.xtext.scoping.NameFunctions;

import com.google.common.base.Predicate;
import com.google.common.collect.Lists;

@SuppressWarnings("all")
public class «getScopeProvider().toSimpleName()» extends AbstractPolymorphicScopeProvider {

  /** Class-wide logger. */
  private static final Logger LOGGER = Logger.getLogger(«getScopeProvider().toSimpleName()».class);
«IF model != null -»

«EXPAND scopeMethods(name.toSimpleName()) FOR model-»
«ENDIF-»

}
«ENDFILE»
«ENDDEFINE»

«DEFINE scopeMethods(String baseName) FOR ScopeModel-»
  /** {@inheritDoc} */
  @Override
  protected IScope doGetScope(final EObject context, final EReference reference, final String scopeName, final Resource originalResource) {
    «FOREACH allScopes().select(s|s.reference != null).collect(s|s.getScopeName()).toSet().sortBy(n|n=="scope"? "" : n) AS name SEPARATOR " else "
   »if ("«name»".equals(scopeName)) {
      «FOREACH allScopes().select(s|s.reference != null).select(s|s.getScopeName()==name) AS scope-»
      if (reference == «scope.reference.literalIdentifier()») return «scope.scopeMethodName()»(context, reference, originalResource);
      «ENDFOREACH-»
    }«
    ENDFOREACH»
    return null;
  }

  /** {@inheritDoc} */
  @Override
  protected IScope doGetScope(final EObject context, final EClass type, final String scopeName, final Resource originalResource) {
    «FOREACH allScopes().select(s|s.reference == null).collect(s|s.getScopeName()).toSet().sortBy(n|n=="scope"? "" : n) AS name SEPARATOR " else "
   »if ("«name»".equals(scopeName)) {
      «FOREACH allScopes().select(s|s.reference == null).select(s|s.getScopeName()==name) AS scope-»
      if (type == «scope.targetType.literalIdentifier()») return «scope.scopeMethodName()»(context, type, originalResource);
      «ENDFOREACH-»
    }«
    ENDFOREACH»
    return null;
  }

  /** {@inheritDoc} */
  @Override
  protected boolean doGlobalCache(final EObject context, final EReference reference, final String scopeName, final Resource originalResource) {
    if (context.eContainer() == null) {
      «FOREACH allScopes().select(s|s.reference != null).select(s|s.allScopeRules().select(r|r.context.global).size > 0).collect(s|s.getScopeName()).toSet().sortBy(n|n=="scope"? "" : n) AS name SEPARATOR " else "
     »if ("«name»".equals(scopeName)) {
        «FOREACH allScopes().select(s|s.reference != null).select(s|s.getScopeName()==name) AS scope-»
        «LET scope.allScopeRules().select(r|r.context.global) AS globalRules-»
        «IF globalRules.size > 0-»
        if (reference == «scope.reference.literalIdentifier()») return true;
        «ENDIF-»
        «ENDLET-»
        «ENDFOREACH-»
      }«
      ENDFOREACH»
    }
    return false;
  }

  /** {@inheritDoc} */
  @Override
  protected boolean doGlobalCache(final EObject context, final EClass type, final String scopeName, final Resource originalResource) {
    if (context.eContainer() == null) {
      «FOREACH allScopes().select(s|s.reference == null).select(s|s.allScopeRules().select(r|r.context.global).size > 0).collect(s|s.getScopeName()).toSet().sortBy(n|n=="scope"? "" : n) AS name SEPARATOR " else "
     »if ("«name»".equals(scopeName)) {
        «FOREACH allScopes().select(s|s.reference == null).select(s|s.getScopeName()==name) AS scope-»
        «LET scope.allScopeRules().select(r|r.context.global) AS globalRules-»
        «IF globalRules.size > 0-»
        if (type == «scope.targetType.literalIdentifier()») return true;
        «ENDIF-»
        «ENDLET-»
        «ENDFOREACH-»
      }«
      ENDFOREACH»
    }
    return false;
  }

  «FOREACH allScopes() AS scope-»
  protected IScope «scope.scopeMethodName()»(final EObject context, final «IF scope.reference != null-»EReference ref«ELSE-»EClass type«ENDIF-», final Resource originalResource) {
    «LET scope.allScopeRules().reject(r|r.context.global) AS localRules-»
    «LET scope.allScopeRules().select(r|r.context.global) AS globalRules-»
    «IF globalRules.size > 1-»«ERROR "only one global rule allowed"-»«ENDIF-»
    «FOREACH localRules.filterUniqueRules().sortedRules() AS r-»
    «javaContributorComment(r.location())»
    if («IF r.context.contextType == org::eclipse::emf::ecore::EcorePackage$Literals::EOBJECT»true«ELSE»context instanceof «r.context.contextType.instanceClassName()»«ENDIF») {
      final «r.context.contextType.instanceClassName()» ctx = («r.context.contextType.instanceClassName()») context;
     «LET localRules.select(r2|r2.hasSameContext(r)) AS rulesForTypeAndContext-»
      «EXPAND scopeRuleBlock(this, r.contextRef() != null ? 'ref' : 'type', r.context.contextType, r.context.global, 3) FOR rulesForTypeAndContext-»
     «ENDLET-»
    }
    «ENDFOREACH-»
    «IF !localRules.isEmpty || !globalRules.isEmpty-»

    final EObject eContainer = context.eContainer();
    if (eContainer != null) {
      return internalGetScope(«IF !localRules.isEmpty-»eContainer«ELSE-»getRootObject(eContainer)«ENDIF-», «IF scope.reference != null-»ref«ELSE-»type«ENDIF-», "«scope.getScopeName()»", originalResource);
    }

    «ENDIF-»
    «IF !globalRules.isEmpty-»
    «LET globalRules.first() AS r-»
     «LET {r} AS rulesForTypeAndContext-»
    «javaContributorComment(r.location())»
    if (context.eResource() != null) {
      final Resource ctx = context.eResource();
      «EXPAND scopeRuleBlock(this, r.contextRef() != null ? 'ref' : 'type', r.context.contextType, r.context.global, 3) FOR rulesForTypeAndContext-»
    }

     «ENDLET-»
    «ENDLET-»
    «ENDIF-»
    «ENDLET-»
    «ENDLET-»
    return null;
  }

  «ENDFOREACH-»
«ENDDEFINE»

«DEFINE scopeRuleBlock(ScopeModel model, String typeOrRef, EClass contextType, Boolean isGlobal, Integer indent) FOR List[ScopeRule]-»
«indent(indent)»IScope scope = IScope.NULLSCOPE;
«indent(indent)»try {
      «IF this.exists(r|r.context.guard != null)-»
«indent(indent+1)»«FOREACH this.sortBy(r|r.context.guard == null ? this.size : this.indexOf(r)) AS r SEPARATOR ' else '
        »«IF r.context.guard != null»if («r.context.guard.javaExpression(model.compilationContext().clone('ctx', r.scopeType()))») «ENDIF»{
«indent(indent+2)»«IF this.size > 1»«javaContributorComment(r.location())»
        «ENDIF
        »«EXPAND scopes(model, typeOrRef, r.getScope(), isGlobal, indent+2) FOREACH r.exprs.reverse()-»
«indent(indent+1)»}«
      ENDFOREACH»«
      IF !this.exists(r|r.context.guard == null)-» else {
«indent(indent+1)»  throw new UnsupportedOperationException(); // continue matching other definitions
«indent(indent+1)»}«ENDIF»
      «ELSEIF this.size == 1-»
        «EXPAND scopes(model, typeOrRef, this.first().getScope(), isGlobal, indent+1) FOREACH this.first().exprs.reverse()-»
      «ELSE-»
        «ERROR 'scope context not unique for definitions: ' + ', '.join(this.collect(r|r.location()))»
      «ENDIF-»
«indent(indent)»} catch (Exception e) {
«indent(indent)»  LOGGER.error("Error calculating scope for «isGlobal ? "Resource" : contextType.name» («this.get(0).locatorString()»)", e);
«indent(indent)»}
«indent(indent)»return scope;
«ENDDEFINE»

«DEFINE scopes(ScopeModel model, String typeOrRef, ScopeDefinition scope, Boolean isGlobal, Integer indent) FOR ScopeExpression-»
«IF prune != null»«EXPAND pruning (model, scope, indent) FOR this-»«ENDIF-»
«EXPAND scopeExpression (model, typeOrRef, scope, isGlobal, indent) FOR this-»
«ENDDEFINE»

«DEFINE scopeExpression (ScopeModel model, String typeOrRef, ScopeDefinition scope, Boolean isGlobal, Integer indent) FOR ScopeExpression-»
«ERROR "Xpand called the wrong definition." + this.toString() + javaContributorComment(this.location())»
«ENDDEFINE»

«DEFINE scopeExpression (ScopeModel model, String typeOrRef, ScopeDefinition scope, Boolean isGlobal, Integer indent) FOR FactoryExpression-»«
LET model.compilationContext().clone('ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType) AS ctx -»
«indent(indent)»scope = «EXPAND javaCall(ctx) FOR this.expr»(scope, ctx, «typeOrRef», originalResource«
IF OperationCall.isInstance (expr) && !((OperationCall) expr).params.isEmpty», «', '.join(((OperationCall) expr).params.javaExpression(ctx))»«ENDIF»);
«ENDLET-»
«ENDDEFINE»

«DEFINE javaCall(CompilationContext ctx) FOR Expression-»
/* Error: cannot handle scope factory «this.toString()» */
«ENDDEFINE»

«DEFINE javaCall(CompilationContext ctx) FOR OperationCall-»
«IF isJavaExtensionCall(ctx) -»«calledJavaMethod(ctx) -»«
 ELSE-»/* Error: cannot handle scope factory «this.toString()» */«
 ENDIF-»
«ENDDEFINE»

«DEFINE scopeExpression (ScopeModel model, String typeOrRef, ScopeDefinition scope, Boolean isGlobal, Integer indent) FOR ScopeDelegation-»
«IF delegate != null -»
«LET delegate.serialize() AS delegateString -»
«IF delegateString == "this.eContainer()" || delegateString == "this.eContainer" || delegateString == "eContainer()" || delegateString == "eContainer" -»
«indent(indent)»scope = newSameScope("«this.locatorString()»", scope, ctx.eContainer()«
ELSEIF delegateString == "this"-»
«indent(indent)»scope = newSameScope("«this.locatorString()»", scope, ctx«
ELSE -»
«indent(indent)»scope = newDelegateScope("«this.locatorString()»", scope, «
IF !isGlobal -»() -> IContextSupplier.makeIterable(«EXPAND scopedElements(model, ((ScopeRule) eContainer(ScopeRule)).context.contextType, 'ctx') FOR delegate»)«
ELSE»«EXPAND scopedElements(model, ((ScopeRule) eContainer(ScopeRule)).context.contextType, 'ctx') FOR delegate»«
ENDIF»«
ENDIF»«
ENDLET»«
ELSE-»
«indent(indent)»scope = newExternalDelegateScope("«this.locatorString()»", scope, «
EXPAND query(model, typeOrRef, scope, indent) FOR external».execute(ctx, originalResource)«
ENDIF», «
IF this.scope != null && this.scope.typeOrRef() != this.getScope().typeOrRef()»«this.scope.typeOrRef().literalIdentifier()»«ELSE»«typeOrRef»«ENDIF», "«this.scope != null && this.scope.name != null ? this.scope.name : "scope"»", originalResource);
«ENDDEFINE»

«DEFINE scopeExpression (ScopeModel model, String typeOrRef, ScopeDefinition scope, Boolean isGlobal, Integer indent) FOR NamedScopeExpression-»
«indent(indent)»scope = «EXPAND scopeExpressionPart (model, typeOrRef, scope, indent) FOR this-»
«EXPAND scopeExpressionNaming (model, typeOrRef, scope, indent) FOR this-»
«EXPAND scopeExpressionCasing (model, typeOrRef, scope, indent) FOR this-»);
«ENDDEFINE»

«DEFINE scopeExpression (ScopeModel model, String typeOrRef, ScopeDefinition scope, Boolean isGlobal, Integer indent) FOR SimpleScopeExpression-»
«IF expr.isEmptyList() -»
«indent(indent)»// Empty scope from «this.location()»
«ELSE-»
«indent(indent)»scope = «EXPAND scopeExpressionPart (model, typeOrRef, scope, indent) FOR this-»
«EXPAND scopeExpressionNaming (model, typeOrRef, scope, indent) FOR this-»
«EXPAND scopeExpressionCasing (model, typeOrRef, scope, indent) FOR this-»);
«ENDIF-»
«ENDDEFINE»

«DEFINE scopeExpressionPart (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR NamedScopeExpression-»
«ERROR "Xtend called the wrong definition for scopeExpressionPart with this=" + this.toString() + javaContributorComment(this.location())»«
ENDDEFINE»

«DEFINE scopeExpressionPart (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR SimpleScopeExpression-»
newSimpleScope("«this.locatorString()»", scope, «EXPAND scopedElements(model, ((ScopeRule) eContainer(ScopeRule)).context.contextType, "ctx") FOR expr», «
ENDDEFINE»

«DEFINE query (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR GlobalScopeExpression-»
newQuery(«type.literalIdentifier()»)«
LET data.select(d|MatchDataExpression.isInstance(d)) AS matchData»«
IF name != null».name(«EXPAND doExpression (model, 'ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType) FOR name»)«ENDIF»«
IF !matchData.isEmpty»«FOREACH matchData AS d».data("«javaEncode(d.key)»", «EXPAND doExpression (model, 'ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType) FOR d.value»)«ENDFOREACH»«ENDIF»«
IF !domains.isEmpty && domains.get(0) != "*"».domains(«FOREACH domains AS d SEPARATOR ", "»"«javaEncode(d)»"«ENDFOREACH»)«ENDIF»«
ENDLET»«
ENDDEFINE»

«DEFINE scopeExpressionPart (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR GlobalScopeExpression-»
«LET data.select(d|LambdaDataExpression.isInstance(d)) AS matchData -»
«IF matchData.isEmpty && prefix == null»newContainerScope(«ELSEIF matchData.isEmpty && prefix != null»newPrefixedContainerScope(«ELSE»newDataMatchScope(«ENDIF»"«this.locatorString()»", scope, ctx, «EXPAND query (model, typeOrRef, scope, indent) FOR this», originalResource«
IF !matchData.isEmpty», //
«indent(indent)»  Lists.<Predicate<IEObjectDescription>>newArrayList(
«FOREACH matchData AS d SEPARATOR ","-»
«LET model.compilationContext().cloneWithVariable('ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType, d.desc, 'org::eclipse::xtext::resource::IEObjectDescription') AS cc-»
«indent(indent)»    new Predicate<IEObjectDescription>() {
«indent(indent)»      public boolean apply (final IEObjectDescription «d.desc») {
«IF d.value.isCompilable(((CompilationContext) cc).clone('ctx'))-»
«indent(indent)»        return «d.value.javaExpression(((CompilationContext) cc).clone('ctx'))»;
«ELSE-»
«indent(indent)»        EXPRESSION_NOT_SUPPORTED("«serialize()»");
«ENDIF-»
«indent(indent)»      }
«indent(indent)»    }«
ENDLET»«
ENDFOREACH»)«
ELSEIF prefix != null», «EXPAND doExpression (model, 'ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType) FOR prefix»«
ENDIF»«ENDLET»«
ENDDEFINE»

«DEFINE scopeExpressionNaming (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR NamedScopeExpression-»
«ERROR "Xtend called the wrong definition for scopeExpressionNaming with this=" + this.toString() + javaContributorComment(this.location())»«
ENDDEFINE»

«DEFINE scopeExpressionNaming (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR SimpleScopeExpression-»
«EXPAND name(model, typeOrRef, 'ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType) FOR this-»
«ENDDEFINE»

«DEFINE scopeExpressionNaming (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR GlobalScopeExpression-»
, «EXPAND name(model, typeOrRef, 'ctx', ((ScopeRule) eContainer(ScopeRule)).context.contextType) FOR this-»«
ENDDEFINE»

«DEFINE scopeExpressionCasing (ScopeModel model, String typeOrRef, ScopeDefinition scope, Integer indent) FOR NamedScopeExpression-»
, «this.isCaseInsensitive() ? "true" : "false"»«
ENDDEFINE»

«DEFINE pruning (ScopeModel model, ScopeDefinition scope, Integer indent) FOR ScopeExpression-»
«indent(indent)»scope = newPruningScope("«this.locatorString()»", scope, new Predicate<org.eclipse.xtext.naming.QualifiedName>() {
«EXPAND prunePredicate(model, ((ScopeRule) eContainer()).context.contextType, 'ctx', indent+2) FOR prune-»);
«ENDDEFINE»

«DEFINE prunePredicate(ScopeModel model, EClass type, String object, Integer indent) FOR Expression-»
«indent(indent)»    public boolean apply(org.eclipse.xtext.naming.QualifiedName name) {
«IF isCompilable(model.compilationContext().cloneWithVariable(object, type, "name", "org::eclipse::xtext::naming::QualifiedName"))-»
«indent(indent)»      return «javaExpression(model.compilationContext().cloneWithString(object, type, "name"))»;
«ELSE-»
«indent(indent)»      EXPRESSION_NOT_SUPPORTED("«serialize()»");
«ENDIF-»
«indent(indent)»    }
«indent(indent)»  }«
ENDDEFINE»

«DEFINE scopedElements(ScopeModel model, EClass type, String object) FOR Expression -»
«EXPAND doExpression(model, object, type) FOR this»«
ENDDEFINE»

«DEFINE doExpression(ScopeModel model, String object, EClass type) FOR Expression -»«
javaExpression (model.compilationContext().clone(object, type))»«
ENDDEFINE»

«DEFINE name(ScopeModel model, String typeOrRef, String contextName, EClass contextType) FOR NamedScopeExpression-»
«IF this.naming != null-»«EXPAND ScopeNameProvider::nameFunctions(model, contextName, contextType) FOR this.naming»«
ELSE»getNameFunctions(«typeOrRef»)«ENDIF»«
ENDDEFINE»