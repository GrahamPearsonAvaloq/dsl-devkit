«REM»
/*******************************************************************************
 * Copyright (c) 2016 Avaloq Evolution AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Evolution AG - initial API and implementation
 *******************************************************************************/
«ENDREM»
«IMPORT org::eclipse::xtext»
«IMPORT org::eclipse::emf::ecore»
«IMPORT com::avaloq::tools::ddk::xtext::expression::expression»
«IMPORT com::avaloq::tools::ddk::xtext::export::export»
«IMPORT com::avaloq::tools::ddk::xtext::generator::expression» «REM»for CompilationContext«ENDREM»

«EXTENSION com::avaloq::tools::ddk::xtext::export::generator::ExportUtil»

«EXTENSION com::avaloq::tools::ddk::xtext::generator::util::GeneratorUtil»«REM»for file extensions stuff«ENDREM»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::util::GenModelUtil2»«REM»for instanceClassName«ENDREM»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::expression::CodeGeneration»«REM»for javaEncode«ENDREM»

«EXTENSION org::eclipse::xtext::GrammarUtil»
«EXTENSION org::eclipse::xtext::generator::Naming»

«DEFINE generate(ExportModel model) FOR Grammar»
«IF model != null -»
«EXPAND generateExportedNameProvider (model) FOR this-»
«ENDIF-»
«ENDDEFINE»

«DEFINE generateExportedNameProvider(ExportModel model) FOR Grammar»
«FILE getExportedNamesProvider().asPath()+".java" SRC_GEN -»
package «getExportedNamesProvider().toJavaPackage()»;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.naming.QualifiedName;

import com.avaloq.tools.ddk.xtext.naming.AbstractExportedNameProvider;
«LET model.compilationContext() AS ctx-»


/**
 * Qualified name provider for grammar «name» providing the qualified names for exported objects.
 */
public class «getExportedNamesProvider().toSimpleName()» extends AbstractExportedNameProvider {

«IF !model.exports.isEmpty -»
«LET model.exports AS types-»
  @Override
  public QualifiedName qualifiedName(final EObject object) {
    EClass eClass = object.eClass();
    EPackage ePackage = eClass.getEPackage();
«LET types.type.toSet() AS exportedEClasses-»
«LET types.sortedExportsByEPackage() AS exportsMap-»
«FOREACH exportsMap.keySet().sortBy(p|((EPackage) p).nsURI) AS p-»
    if (ePackage == «((EPackage) p).qualifiedPackageInterfaceName()».eINSTANCE) {
      int classifierID = eClass.getClassifierID();
      switch (classifierID) {
«FOREACH ((EPackage) p).EClassifiers.typeSelect(EClass).select(c|exportedEClasses.exists(e|e.isSuperTypeOf(c))) AS c-»
      case «c.classifierIdLiteral()»: {
        return qualifiedName((«c.instanceClassName()») object);
      }
«ENDFOREACH-»
      default:
        return null;
      }
    }
«ENDFOREACH-»
«ENDLET-»
«ENDLET-»
    return null;
  }

«FOREACH types AS c-»
	/**
	 * Return the qualified name under which a «c.type.name» object is exported, or <code>null</code> if the object should not be exported.
	 *
	 * @param obj
	 *          The object to be exported
	 * @return The object's qualified name, or <code>null</code> if the object is not to be exported
	 */
	protected QualifiedName qualifiedName(final «c.type.instanceClassName()» obj) {
		«javaContributorComment(c.location())»
«IF c.naming != null -»
		final Object name = «c.naming.javaExpression(ctx.clone('obj', c.type))»;
		return name != null ? «IF c.qualifiedName»getConverter().toQualifiedName(String.valueOf(name))«ELSE»qualifyWithContainerName(obj, String.valueOf(name))«ENDIF» : null;
«ELSE-»
		return «IF c.qualifiedName»getConverter().toQualifiedName(getResolver().apply(obj))«ELSE»qualifyWithContainerName(obj, getResolver().apply(obj))«ENDIF»; // "name" attribute by default
«ENDIF-»
	}

«ENDFOREACH-»
«ENDLET-»
«ENDIF-»
}
«ENDLET-»
«ENDFILE»
«ENDDEFINE»
