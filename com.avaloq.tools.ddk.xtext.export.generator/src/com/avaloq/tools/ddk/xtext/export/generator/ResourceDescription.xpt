«REM»
/*******************************************************************************
 * Copyright (c) 2016 Avaloq Evolution AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Evolution AG - initial API and implementation
 *******************************************************************************/
«ENDREM»
«IMPORT org::eclipse::xtext»
«IMPORT org::eclipse::emf::ecore»
«IMPORT com::avaloq::tools::ddk::xtext::expression::expression»
«IMPORT com::avaloq::tools::ddk::xtext::export::export»
«IMPORT com::avaloq::tools::ddk::xtext::generator::expression» «REM»for CompilationContext«ENDREM»

«EXTENSION com::avaloq::tools::ddk::xtext::export::generator::ExportUtil»

«EXTENSION com::avaloq::tools::ddk::xtext::generator::util::GeneratorUtil»«REM»for file extensions stuff«ENDREM»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::util::GenModelUtil2»«REM»for instanceClassName«ENDREM»
«EXTENSION com::avaloq::tools::ddk::xtext::generator::expression::CodeGeneration»«REM»for javaEncode«ENDREM»

«EXTENSION org::eclipse::xtext::GrammarUtil»
«EXTENSION org::eclipse::xtext::generator::Naming»

«DEFINE generate(ExportModel model) FOR Grammar»
«IF model != null -»
«EXPAND generateResourceDescriptionStrategy(model) FOR this-»
«EXPAND generateResourceDescriptionConstants(model) FOR this-»
«ENDIF-»
«ENDDEFINE»

«DEFINE generateResourceDescriptionConstants(ExportModel model) FOR Grammar»
«FILE getResourceDescriptionConstants().asPath()+".java" SRC_GEN -»
package «getResourceDescriptionConstants().toJavaPackage()»;

public interface «getResourceDescriptionConstants().toSimpleName()» {
«LET model.exports AS types-»
«FOREACH types.select(e|!e.type.abstract) AS c-»
«LET c.allExportedAttributes() AS a-»
«LET c.allUserData() AS d-»
«IF !a.isEmpty || !d.isEmpty -»
  // Export «c.type.name»
«IF !a.isEmpty -»
«FOREACH a AS attr -»
  public static final String «attr.constantName(c.type)» = "«attr.name.javaEncode()»"; //$NON-NLS-1$
«ENDFOREACH-»
«ENDIF-»
«IF !d.isEmpty -»
«FOREACH d AS data -»
  public static final String «data.constantName(c.type)» = "«data.name.javaEncode()»"; //$NON-NLS-1$
«ENDFOREACH-»
«ENDIF-»

«ENDIF-»
«ENDLET-»
«ENDLET-»
«ENDFOREACH-»
«ENDLET-»
}
«ENDFILE-»
«ENDDEFINE»

«DEFINE generateResourceDescriptionStrategy(ExportModel model) FOR Grammar»
«FILE getResourceDescriptionStrategy().asPath()+".java" SRC_GEN -»
package «getResourceDescriptionStrategy().toJavaPackage()»;

import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.util.Switch;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.util.IAcceptor;

import com.avaloq.tools.ddk.xtext.resource.AbstractResourceDescriptionStrategy;
«IF model.exports.exists(e|e.fingerprint||e.resourceFingerprint)-»
import com.avaloq.tools.ddk.xtext.resource.IFingerprintComputer;
«ENDIF-»
«IF model.exports.exists(e|e.allowLookup)-»
import com.avaloq.tools.ddk.xtext.resource.DetachableEObjectDescription;
«ENDIF-»
import com.google.common.collect.ForwardingMap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
«LET model.exports AS types-»


public class «getResourceDescriptionStrategy().toSimpleName()» extends AbstractResourceDescriptionStrategy {

  private static final Set<EClass> EXPORTED_ECLASSES = ImmutableSet.copyOf(new EClass[] {
«LET types.typeMap(this) AS e-»
«FOREACH e.keySet().flatten().sortBy(e|((EClass) e).literalIdentifier()) AS c SEPARATOR ',
'-»    «((EClass) c).literalIdentifier()-»
«ENDFOREACH-»
«ENDLET»
  });

  @Override
  public Set<EClass> getExportedEClasses(final Resource resource) {
    return EXPORTED_ECLASSES;
  }

«IF !types.isEmpty -»
«LET model.compilationContext() AS ctx-»
  private final ThreadLocal<IAcceptor<IEObjectDescription>> acceptor = new ThreadLocal<IAcceptor<IEObjectDescription>>();

«FOREACH types.select(e|!e.type.abstract).type.EPackage.toSet().sortBy(p|p.nsURI) AS p -»
  private final Switch<Boolean> «p.name»ExportSwitch = new «p.qualifiedSwitchClassName()»<Boolean>() {

    @Override
    public Boolean defaultCase(final EObject obj) {
      return true;
    }
«FOREACH types.select(e|!e.type.abstract && e.type.EPackage == p) AS c -»

    «javaContributorComment(c.location())»
    @Override
    public Boolean case«c.type.name»(final «c.type.instanceClassName()» obj) {
«IF c.guard != null-»
      «javaContributorComment(c.guard.location())»
      if («c.guard.javaExpression(ctx.clone('obj', c.type))») {
«ENDIF-»
«LET c.allExportedAttributes() AS a-»
«LET c.allUserData() AS d-»
«IF !a.isEmpty || !d.isEmpty || c.fingerprint || c.resourceFingerprint || c.allowLookup -»
      // Use a forwarding map to delay calculation as much as possible; otherwise we may get recursive EObject resolution attempts
      Map<String, String> data = new ForwardingMap<String, String>() {
        private Map<String, String> delegate;

        @Override
        protected Map<String, String> delegate() {
          if (delegate == null) {
            ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
            Object value = null;
«IF c.fingerprint-»
            // Fingerprint
            value = getFingerprint(obj);
            if (value != null) {
              builder.put(IFingerprintComputer.OBJECT_FINGERPRINT, value.toString());
            }
«ELSEIF c.resourceFingerprint-»
            // Resource fingerprint
            value = getFingerprint(obj);
            if (value != null) {
              builder.put(IFingerprintComputer.RESOURCE_FINGERPRINT, value.toString());
            }
«ENDIF-»
«IF c.allowLookup-»
            // Allow lookups
            builder.put(DetachableEObjectDescription.ALLOW_LOOKUP, Boolean.TRUE.toString());
«ENDIF-»
«IF !a.isEmpty -»
            // Exported attributes
«FOREACH a AS attr -»
            value = obj.eGet(«attr.literalIdentifier()», false);
            if (value != null) {
              builder.put(«getResourceDescriptionConstants().toSimpleName()».«attr.constantName(c.type)», value.toString());
            }
«ENDFOREACH-»
«ENDIF-»
«IF !d.isEmpty -»
            // User data
«FOREACH d AS data -»
            value = «data.expr.javaExpression(ctx.clone('obj', c.type))»;
            if (value != null) {
              builder.put(«getResourceDescriptionConstants().toSimpleName()».«data.constantName(c.type)», value.toString());
            }
«ENDFOREACH-»
«ENDIF-»
            delegate = builder.build();
          }
          return delegate;
        }
      };
      acceptEObjectDescription(obj, data, acceptor.get());
«ELSE-»
      acceptEObjectDescription(obj, acceptor.get());
«ENDIF-»
«ENDLET-»
«ENDLET-»
«IF c.guard != null-»
      }
«ENDIF-»

      // can «c.type.name» contain any nested «types.type.select(e|!e.abstract).name.toSet()» objects ?
      return «c.type.canContain(types.type.select(e|!e.abstract).toSet(), this)»;
    }
«ENDFOREACH-»
  };

«ENDFOREACH-»
  @Override
  protected boolean doCreateEObjectDescriptions(final EObject object, final IAcceptor<IEObjectDescription> acceptor) {
    try {
      this.acceptor.set(acceptor);
      final EPackage ePackage = object.eClass().getEPackage();
«FOREACH types.select(e|!e.type.abstract).type.EPackage.toSet().sortBy(p|p.nsURI) AS p -»
      if (ePackage == «p.qualifiedPackageInterfaceName()».eINSTANCE) {
        return «p.name»ExportSwitch.doSwitch(object);
      }
«ENDFOREACH-»
      // TODO: generate code for other possible epackages (as defined by grammar)
      return true;
    } finally {
      this.acceptor.set(null);
    }
  }

«ENDLET-»
«ENDIF-»
«ENDLET-»
}
«ENDFILE»
«ENDDEFINE»
