/*
 * generated by Xtext
 */
package com.avaloq.tools.ddk.xtext.expression.serializer;

import com.avaloq.tools.ddk.xtext.expression.expression.BooleanLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.BooleanOperation;
import com.avaloq.tools.ddk.xtext.expression.expression.Case;
import com.avaloq.tools.ddk.xtext.expression.expression.CastedExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ChainExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.CollectionExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ConstructorCallExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ExpressionPackage;
import com.avaloq.tools.ddk.xtext.expression.expression.FeatureCall;
import com.avaloq.tools.ddk.xtext.expression.expression.GlobalVarExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.Identifier;
import com.avaloq.tools.ddk.xtext.expression.expression.IfExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.IntegerLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.LetExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ListLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.NullLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.OperationCall;
import com.avaloq.tools.ddk.xtext.expression.expression.RealLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.StringLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.SwitchExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.TypeSelectExpression;
import com.avaloq.tools.ddk.xtext.expression.services.ExpressionGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractExpressionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ExpressionGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ExpressionPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ExpressionPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_OPERATION:
				sequence_AndExpression_ImpliesExpression_OrExpression_RelationalExpression(context, (BooleanOperation) semanticObject); 
				return; 
			case ExpressionPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case ExpressionPackage.CASTED_EXPRESSION:
				sequence_CastedExpression(context, (CastedExpression) semanticObject); 
				return; 
			case ExpressionPackage.CHAIN_EXPRESSION:
				sequence_ChainExpression(context, (ChainExpression) semanticObject); 
				return; 
			case ExpressionPackage.COLLECTION_EXPRESSION:
				if(context == grammarAccess.getCollectionExpressionRule() ||
				   context == grammarAccess.getFeatureCallRule()) {
					sequence_CollectionExpression(context, (CollectionExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getChainExpressionRule() ||
				   context == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0() ||
				   context == grammarAccess.getChainedExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getIfExpressionTriRule() ||
				   context == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0() ||
				   context == grammarAccess.getImpliesExpressionRule() ||
				   context == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getSyntaxElementRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_CollectionExpression_InfixExpression(context, (CollectionExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.CONSTRUCTOR_CALL_EXPRESSION:
				sequence_ConstructorCallExpression(context, (ConstructorCallExpression) semanticObject); 
				return; 
			case ExpressionPackage.FEATURE_CALL:
				if(context == grammarAccess.getFeatureCallRule()) {
					sequence_FeatureCall(context, (FeatureCall) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getChainExpressionRule() ||
				   context == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0() ||
				   context == grammarAccess.getChainedExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getIfExpressionTriRule() ||
				   context == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0() ||
				   context == grammarAccess.getImpliesExpressionRule() ||
				   context == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getSyntaxElementRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_FeatureCall_InfixExpression(context, (FeatureCall) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.GLOBAL_VAR_EXPRESSION:
				sequence_GlobalVarExpression(context, (GlobalVarExpression) semanticObject); 
				return; 
			case ExpressionPackage.IDENTIFIER:
				if(context == grammarAccess.getCollectionTypeRule()) {
					sequence_CollectionType(context, (Identifier) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSyntaxElementRule() ||
				   context == grammarAccess.getTypeRule()) {
					sequence_CollectionType_SimpleType_Type(context, (Identifier) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getSimpleTypeRule()) {
					sequence_SimpleType(context, (Identifier) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.IF_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getChainExpressionRule() ||
				   context == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0() ||
				   context == grammarAccess.getChainedExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getIfExpressionTriRule() ||
				   context == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0() ||
				   context == grammarAccess.getImpliesExpressionRule() ||
				   context == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getSyntaxElementRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_ChainedExpression_IfExpressionKw_IfExpressionTri(context, (IfExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getIfExpressionKwRule()) {
					sequence_IfExpressionKw(context, (IfExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case ExpressionPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case ExpressionPackage.LIST_LITERAL:
				sequence_ListLiteral(context, (ListLiteral) semanticObject); 
				return; 
			case ExpressionPackage.NULL_LITERAL:
				sequence_NullLiteral(context, (NullLiteral) semanticObject); 
				return; 
			case ExpressionPackage.OPERATION_CALL:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getChainExpressionRule() ||
				   context == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0() ||
				   context == grammarAccess.getChainedExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getIfExpressionTriRule() ||
				   context == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0() ||
				   context == grammarAccess.getImpliesExpressionRule() ||
				   context == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getSyntaxElementRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_AdditiveExpression_InfixExpression_MultiplicativeExpression_OperationCall_UnaryExpression_UnaryOrInfixExpression(context, (OperationCall) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFeatureCallRule() ||
				   context == grammarAccess.getOperationCallRule()) {
					sequence_OperationCall(context, (OperationCall) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUnaryExpressionRule()) {
					sequence_UnaryExpression(context, (OperationCall) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case ExpressionPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ExpressionPackage.SWITCH_EXPRESSION:
				sequence_SwitchExpression(context, (SwitchExpression) semanticObject); 
				return; 
			case ExpressionPackage.TYPE_SELECT_EXPRESSION:
				if(context == grammarAccess.getAdditiveExpressionRule() ||
				   context == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getAndExpressionRule() ||
				   context == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getChainExpressionRule() ||
				   context == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0() ||
				   context == grammarAccess.getChainedExpressionRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getIfExpressionTriRule() ||
				   context == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0() ||
				   context == grammarAccess.getImpliesExpressionRule() ||
				   context == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getInfixExpressionRule() ||
				   context == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0() ||
				   context == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0() ||
				   context == grammarAccess.getMultiplicativeExpressionRule() ||
				   context == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0() ||
				   context == grammarAccess.getOrExpressionRule() ||
				   context == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getParanthesizedExpressionRule() ||
				   context == grammarAccess.getPrimaryExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionRule() ||
				   context == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0() ||
				   context == grammarAccess.getSyntaxElementRule() ||
				   context == grammarAccess.getUnaryOrInfixExpressionRule()) {
					sequence_InfixExpression_TypeSelectExpression(context, (TypeSelectExpression) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getFeatureCallRule() ||
				   context == grammarAccess.getTypeSelectExpressionRule()) {
					sequence_TypeSelectExpression(context, (TypeSelectExpression) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         ((name='!' | name='-') params+=InfixExpression) | 
	 *         (target=InfixExpression_OperationCall_1_0_0 name=Identifier (params+=Expression params+=Expression*)?) | 
	 *         (name=Identifier (params+=Expression params+=Expression*)?) | 
	 *         (params+=MultiplicativeExpression_OperationCall_1_0 (name='*' | name='/') params+=UnaryOrInfixExpression) | 
	 *         (params+=AdditiveExpression_OperationCall_1_0 (name='+' | name='-') params+=MultiplicativeExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_InfixExpression_MultiplicativeExpression_OperationCall_UnaryExpression_UnaryOrInfixExpression(EObject context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (left=ImpliesExpression_BooleanOperation_1_0 operator='implies' right=RelationalExpression) | 
	 *         (
	 *             left=RelationalExpression_BooleanOperation_1_0 
	 *             (
	 *                 operator='==' | 
	 *                 operator='!=' | 
	 *                 operator='>=' | 
	 *                 operator='<=' | 
	 *                 operator='>' | 
	 *                 operator='<'
	 *             ) 
	 *             right=AdditiveExpression
	 *         ) | 
	 *         (left=AndExpression_BooleanOperation_1_0 operator='&&' right=ImpliesExpression) | 
	 *         (left=OrExpression_BooleanOperation_1_0 operator='||' right=AndExpression)
	 *     )
	 */
	protected void sequence_AndExpression_ImpliesExpression_OrExpression_RelationalExpression(EObject context, BooleanOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (val='true' | val='false')
	 */
	protected void sequence_BooleanLiteral(EObject context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (condition=OrExpression thenPar=OrExpression)
	 */
	protected void sequence_Case(EObject context, Case semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CASE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CASE__CONDITION));
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CASE__THEN_PAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CASE__THEN_PAR));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCaseAccess().getConditionOrExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getCaseAccess().getThenParOrExpressionParserRuleCall_3_0(), semanticObject.getThenPar());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Type target=Expression)
	 */
	protected void sequence_CastedExpression(EObject context, CastedExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CASTED_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CASTED_EXPRESSION__TYPE));
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CASTED_EXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CASTED_EXPRESSION__TARGET));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCastedExpressionAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCastedExpressionAccess().getTargetExpressionParserRuleCall_3_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (first=ChainExpression_ChainExpression_1_0 next=ChainedExpression)
	 */
	protected void sequence_ChainExpression(EObject context, ChainExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CHAIN_EXPRESSION__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CHAIN_EXPRESSION__FIRST));
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CHAIN_EXPRESSION__NEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CHAIN_EXPRESSION__NEXT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getChainExpressionAccess().getNextChainedExpressionParserRuleCall_1_2_0(), semanticObject.getNext());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (condition=ChainedExpression thenPart=ChainedExpression elsePart=ChainedExpression?) | 
	 *         (condition=IfExpressionTri_IfExpression_1_0 thenPart=ChainedExpression elsePart=ChainedExpression)
	 *     )
	 */
	protected void sequence_ChainedExpression_IfExpressionKw_IfExpressionTri(EObject context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             name='collect' | 
	 *             name='select' | 
	 *             name='selectFirst' | 
	 *             name='reject' | 
	 *             name='exists' | 
	 *             name='notExists' | 
	 *             name='sortBy' | 
	 *             name='forAll'
	 *         ) 
	 *         var=Identifier? 
	 *         exp=Expression
	 *     )
	 */
	protected void sequence_CollectionExpression(EObject context, CollectionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (
	 *             target=InfixExpression_CollectionExpression_1_3_0 
	 *             (
	 *                 name='collect' | 
	 *                 name='select' | 
	 *                 name='selectFirst' | 
	 *                 name='reject' | 
	 *                 name='exists' | 
	 *                 name='notExists' | 
	 *                 name='sortBy' | 
	 *                 name='forAll'
	 *             ) 
	 *             var=Identifier? 
	 *             exp=Expression
	 *         ) | 
	 *         (
	 *             (
	 *                 name='collect' | 
	 *                 name='select' | 
	 *                 name='selectFirst' | 
	 *                 name='reject' | 
	 *                 name='exists' | 
	 *                 name='notExists' | 
	 *                 name='sortBy' | 
	 *                 name='forAll'
	 *             ) 
	 *             var=Identifier? 
	 *             exp=Expression
	 *         )
	 *     )
	 */
	protected void sequence_CollectionExpression_InfixExpression(EObject context, CollectionExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((cl='Collection' | cl='List' | cl='Set') id1=SimpleType)
	 */
	protected void sequence_CollectionType(EObject context, Identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (((cl='Collection' | cl='List' | cl='Set') id1=SimpleType) | (id+=Identifier id+=Identifier*))
	 */
	protected void sequence_CollectionType_SimpleType_Type(EObject context, Identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=SimpleType
	 */
	protected void sequence_ConstructorCallExpression(EObject context, ConstructorCallExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.CONSTRUCTOR_CALL_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.CONSTRUCTOR_CALL_EXPRESSION__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstructorCallExpressionAccess().getTypeSimpleTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     type=Type
	 */
	protected void sequence_FeatureCall(EObject context, FeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((target=InfixExpression_FeatureCall_1_1_0 type=Type) | type=Type)
	 */
	protected void sequence_FeatureCall_InfixExpression(EObject context, FeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=Identifier
	 */
	protected void sequence_GlobalVarExpression(EObject context, GlobalVarExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.GLOBAL_VAR_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.GLOBAL_VAR_EXPRESSION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGlobalVarExpressionAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (condition=ChainedExpression thenPart=ChainedExpression elsePart=ChainedExpression?)
	 */
	protected void sequence_IfExpressionKw(EObject context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((target=InfixExpression_TypeSelectExpression_1_2_0 name='typeSelect' type=Type) | (name='typeSelect' type=Type))
	 */
	protected void sequence_InfixExpression_TypeSelectExpression(EObject context, TypeSelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=INT
	 */
	protected void sequence_IntegerLiteral(EObject context, IntegerLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.INTEGER_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.INTEGER_LITERAL__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValINTTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (identifier=Identifier varExpr=Expression target=Expression)
	 */
	protected void sequence_LetExpression(EObject context, LetExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LET_EXPRESSION__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LET_EXPRESSION__IDENTIFIER));
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LET_EXPRESSION__VAR_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LET_EXPRESSION__VAR_EXPR));
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LET_EXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LET_EXPRESSION__TARGET));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getLetExpressionAccess().getIdentifierIdentifierParserRuleCall_1_0(), semanticObject.getIdentifier());
		feeder.accept(grammarAccess.getLetExpressionAccess().getVarExprExpressionParserRuleCall_3_0(), semanticObject.getVarExpr());
		feeder.accept(grammarAccess.getLetExpressionAccess().getTargetExpressionParserRuleCall_5_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((elements+=Expression elements+=Expression*)?)
	 */
	protected void sequence_ListLiteral(EObject context, ListLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val='null'
	 */
	protected void sequence_NullLiteral(EObject context, NullLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.NULL_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.NULL_LITERAL__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNullLiteralAccess().getValNullKeyword_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=Identifier (params+=Expression params+=Expression*)?)
	 */
	protected void sequence_OperationCall(EObject context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=REAL
	 */
	protected void sequence_RealLiteral(EObject context, RealLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.REAL_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.REAL_LITERAL__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValREALTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (id+=Identifier id+=Identifier*)
	 */
	protected void sequence_SimpleType(EObject context, Identifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     val=STRING
	 */
	protected void sequence_StringLiteral(EObject context, StringLiteral semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.STRING_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.STRING_LITERAL__VAL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValSTRINGTerminalRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (switchExpr=OrExpression? case+=Case* defaultExpr=OrExpression)
	 */
	protected void sequence_SwitchExpression(EObject context, SwitchExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name='typeSelect' type=Type)
	 */
	protected void sequence_TypeSelectExpression(EObject context, TypeSelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((name='!' | name='-') params+=InfixExpression)
	 */
	protected void sequence_UnaryExpression(EObject context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
