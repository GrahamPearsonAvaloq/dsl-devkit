/*******************************************************************************
 * Copyright (c) 2016 Avaloq Evolution AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Evolution AG - initial API and implementation
 *******************************************************************************/
import xpand2;
import com::avaloq::tools::ddk::xtext::expression::expression;
import com::avaloq::tools::ddk::xtext::generator::expression;

extension com::avaloq::tools::ddk::xtext::generator::expression::ExpressionExtensions;
extension com::avaloq::tools::ddk::xtext::generator::util::GenModelUtil2;


//////////////////////////////////////////////////
// ENTRY POINTS
//////////////////////////////////////////////////
boolean isCompilable(Expression this, CompilationContext ctx) :
    (let expr = javaExpression (ctx) :
        expr != null && !expr.contains('/* NOT COMPILABLE: ')
    )
;

String javaExpression(Void this, CompilationContext ctx) :
    ''
;

String javaExpression(Expression this, CompilationContext ctx) :
    notCompilable()
;

String notCompilable(Expression this) :
    '/* NOT COMPILABLE: Complex expressions like "' + serialize() + '" cannot be translated to Java. Consider rewriting the expression or using a JAVA extension. */'
;

//////////////////////////////////////////////////
// LITERALS
//////////////////////////////////////////////////
String javaExpression(StringLiteral this, CompilationContext ctx) :
    '"' + javaEncode(val) + '"'
;

String javaExpression(BooleanLiteral this, CompilationContext ctx) :
    val
;

String javaExpression(IntegerLiteral this, CompilationContext ctx) :
    val.toString()
;

String javaExpression(NullLiteral this, CompilationContext ctx) :
    "null"
;

String javaExpression(RealLiteral this, CompilationContext ctx) :
    val.toString()
;

String javaExpression(ListLiteral this, CompilationContext ctx) :
    elements.isEmpty ? "java.util.Collections.<" + ctx.javaType(ctx.requiredType.name) + "> emptyList()" :
        (elements.size == 1 ? "java.util.Collections.singletonList(" + elements.first().javaExpression(ctx) + ")" :
            "com.google.common.collect.Lists.newArrayList(" + ', '.join(elements.javaExpression(ctx)) + ")"
        )
;

//////////////////////////////////////////////////
// TYPES AND VARIABLES
//////////////////////////////////////////////////
String javaExpression(Identifier this, CompilationContext ctx) :
    isThis() ? ctx.implicitVariable : '::'.join(id)
;

boolean isType(FeatureCall this, CompilationContext ctx) :
    name == null && type != null && ctx.findType(type.javaExpression(ctx)) != null
;

boolean isVariable(Expression this, CompilationContext ctx) :
    false
;

boolean isVariable(FeatureCall this, CompilationContext ctx) :
    target == null && name == null && ctx.isVariable(type.javaExpression(ctx))
;

String featureCallTarget(FeatureCall this, CompilationContext ctx) :
    if target == null || target.isThisCall() then
        ctx.implicitVariable
    else
        target.javaExpression(ctx)
;

//////////////////////////////////////////////////
// BOOLEAN OPERATIONS
//////////////////////////////////////////////////
String javaExpression(BooleanOperation this, CompilationContext ctx) :
    autoBracket(left.javaExpression(ctx) + ' ' + operator + ' ' + right.javaExpression(ctx), ctx)
;

//////////////////////////////////////////////////
// COLLECTION OPERATIONS
//////////////////////////////////////////////////
// TODO finish
String javaExpression(CollectionExpression this, CompilationContext ctx) :
    if ('select' == name) then
        'com.google.common.collect.Iterables.filter(' + target.javaExpression(ctx) +
            ', new com.google.common.base.Predicate<Object>() { public boolean apply(Object ' +
            (var != null ? var : 'e') + ') {return ' +
            exp.javaExpression(ctx) + ';} })'
    else
        notCompilable()
;

String javaExpression(TypeSelectExpression this, CompilationContext ctx) :
    isSimpleNavigation(ctx) ?
        'com.google.common.collect.Iterables.filter(' + target.javaExpression(ctx) + ', ' + ctx.javaType(type.javaExpression(ctx)) + '.class)'
        : notCompilable()
;

//////////////////////////////////////////////////
// TYPE CAST
//////////////////////////////////////////////////
String javaExpression(CastedExpression this, CompilationContext ctx) :
    '((' + ctx.javaType(type.javaExpression(ctx)) + ') ' + target.javaExpression(ctx) + ')'
;

//////////////////////////////////////////////////
// IF EXPRESSIONS
//////////////////////////////////////////////////
String javaExpression(IfExpression this, CompilationContext ctx) :
    autoBracket(condition.javaExpression(ctx) + ' ? ' + thenPart.javaExpression(ctx) + ' : ' + elsePart.javaExpression(ctx), ctx)
;

//////////////////////////////////////////////////
// FEATURE CALLS
//////////////////////////////////////////////////
String javaExpression(FeatureCall this, CompilationContext ctx) :
    if isThisCall() then
        ctx.implicitVariable
    else if isVariable(ctx) then
        type.javaExpression(ctx)
    else if isType(ctx) then
        ctx.javaType(type.javaExpression(ctx))
    else if isSimpleFeatureCall(ctx) then
        featureCallTarget(ctx) + '.' + (calledFeature() == 'eContainer' ? 'eContainer' : (calledFeature() == 'isEmpty' ? 'isEmpty' : calledFeature().toFirstUpper().featureCallName())) + '()'
    else if isSimpleNavigation(ctx) then
        notCompilable()
    else
        featureCallTarget(ctx) + '.' + (calledFeature() == 'eContainer' ? 'eContainer' : (calledFeature() == 'isEmpty' ? 'isEmpty' : calledFeature().toFirstUpper().featureCallName())) + '()'
;

// TODO: actually, we should look at the feature and return "is" only if it has a boolean value... Can this be done??
String featureCallName (String this) :
    (this.startsWith('^')
        ? this.subString(1, this.length).toFirstUpper().featureCallName()
        : (this.startsWith('Is') ? 'is' : 'get') + this
    )
;

boolean isSimpleFeatureCall(Expression this, CompilationContext ctx) :
    false
;

boolean isSimpleFeatureCall(FeatureCall this, CompilationContext ctx) :
    metaType.name.contains('FeatureCall') && name == null && type.isFeature() && (target == null || target.isVariable(ctx) || target.isThisCall())
;

boolean isSimpleNavigation(Expression this, CompilationContext ctx) :
    false
;

boolean isSimpleNavigation(TypeSelectExpression this, CompilationContext ctx) :
    true
;

boolean isSimpleNavigation(FeatureCall this, CompilationContext ctx) :
    name == null && type.isFeature() && (target == null || target.isVariable(ctx) || target.isThisCall() || target.isSimpleNavigation(ctx))
;

String navigationRoot(Void this, CompilationContext ctx) :
    ''
;

String navigationRoot(Expression this, CompilationContext ctx) :
    ''
;

String navigationRoot(FeatureCall this, CompilationContext ctx) :
       target != null ? target.navigationRoot(ctx) : (isVariable(ctx) ? javaExpression(ctx) : ctx.implicitVariable)
;

List[String] navigations(Void this, CompilationContext ctx) :
    {}
;

List[String] navigations(Expression this, CompilationContext ctx) :
    {}
;

List[String] navigations(FeatureCall this, CompilationContext ctx) :
    let navs = target.navigations(ctx) :
       navs.isEmpty && (isThisCall() || isVariable(ctx)) ? {} : navs.add(calledFeature())
;

List[String] navigations(TypeSelectExpression this, CompilationContext ctx) :
    target.navigations(ctx).add("typeSelect(" + type.qualifiedTypeName(ctx) + ")")
;

//////////////////////////////////////////////////
// OPERATION CALLS
//////////////////////////////////////////////////
// TODO handle eClass()
// TODO work out if 'this' should be added or not
String javaExpression(OperationCall this, CompilationContext ctx) :
    if (target == null || target.isThisCall()) && ctx.targetHasOperation(this) then
        (target != null ? target.javaExpression(ctx) + '.' : '') + name + '(' + ', '.join(params.javaExpression(ctx)) + ')'
    else if isJavaExtensionCall(ctx) then
        calledJavaMethod(ctx) + '(' + ', '.join((target != null ? {target}.addAll(params) : params).javaExpression(ctx)) + ')'
    else if isArithmeticOperatorCall(ctx) then
        autoBracket((' ' + name + ' ').join(params.collect(e|e.javaExpression(ctx))), ctx)
    else if isSimpleConcatCall() then
        (' + ').join(params.collect(e|e.javaExpression(ctx)))
    else if isPrefixExpression(ctx) then
        autoBracket(name + params.first().javaExpression(ctx), ctx)
    else if 'first' == name && this.params.isEmpty && target != null then
        target.javaExpression(ctx) + '.get(0)'
    else if 'isInstance' == name then
        autoBracket(params.first().javaExpression(ctx) + ' instanceof ' + ctx.javaType(target.serialize()), ctx)
    else if 'eContainer' == name && params.isEmpty then
        target.javaExpression(ctx) + '.eContainer()'
    else if ctx.isExtension(name) then
        notCompilable()
    else
        (target != null ? target.javaExpression(ctx) + '.' : '') + name + '(' + (params.isEmpty ? '' : ', '.join(params.javaExpression(ctx))) + ')'
;

boolean isJavaExtensionCall(Expression this) :
    false
;

boolean isJavaExtensionCall(OperationCall this, CompilationContext ctx) :
    isSimpleCall(ctx) && calledJavaMethod(ctx) != null
;

boolean isSimpleCall(OperationCall this, CompilationContext ctx) :
    (target == null || target.isCompilable(ctx)) && params.forAll(p|p.isCompilable(ctx))
;

String calledJavaMethod(OperationCall this, CompilationContext ctx) :
    ctx.calledJavaMethod(this)
;

cached String calledJavaMethod(CompilationContext this, OperationCall call) :
    getCalledJavaMethod(call)
;

//////////////////////////////////////////////////
// EXPRESSION BRACKETING
//////////////////////////////////////////////////
String autoBracket(Expression this, String javaCode, CompilationContext ctx) :
    requiresBracketing(ctx) ? '(' + javaCode + ')' : javaCode
;

boolean requiresBracketing(Expression this, CompilationContext ctx) :
    (isPrefixExpression(ctx) || isInfixExpression(ctx)) && eContainer() != null && requiresBracketing(this, eContainer(), ctx)
;

boolean requiresBracketing(Literal this, CompilationContext ctx) :
    false
;

boolean requiresBracketing(Expression this, Object parent, CompilationContext ctx) :
    false
;

boolean requiresBracketing(Expression this, Expression parent, CompilationContext ctx) :
    isPrefixExpression(ctx) && parent.isPrefixExpression(ctx) ||
    (isInfixExpression(ctx) && (parent.isPrefixExpression(ctx) || parent.isInfixExpression(ctx)))
;

boolean requiresBracketing(OperationCall this, OperationCall parent, CompilationContext ctx) :
    isPrefixExpression(ctx) && parent.isPrefixExpression(ctx) ||
    (isInfixExpression(ctx) && (parent.isPrefixExpression(ctx) || (parent.isInfixExpression(ctx) && name != parent.name)))
;

boolean requiresBracketing(BooleanOperation this, BooleanOperation parent, CompilationContext ctx) :
    operator != parent.operator
;

//////////////////////////////////////////////////
// HELPER FUNCTIONS
//////////////////////////////////////////////////
boolean isThisCall(Expression this) :
    false
;

boolean isThisCall(FeatureCall this) :
    name == null && type.isThis()
;

boolean isFeature(Identifier this) :
    id != null && id.size == 1
;

boolean isThis(Expression this) :
    false
;

boolean isThis(Identifier this) :
    id != null && id.size == 1 && id.first() == "this"
;

String qualifiedTypeName(Identifier this, CompilationContext ctx) :
    id.size == 2 ?  id.get(0) + "::" + id.get(1) : ctx.qualifiedTypeName(id.first())
;

cached String qualifiedTypeName(CompilationContext this, String name) :
    getQualifiedTypeName(name)
;

String javaEncode(Expression this) :
    javaEncode(serialize())
;

String javaEncode(String this) :
    JAVA org.eclipse.xtext.util.Strings.convertToJavaString(java.lang.String)
;

String join(String this, List[String] strings) :
    strings.isEmpty ? '' : internalJoin(strings)
;

private String internalJoin(String this, List[String] strings) :
    JAVA org.eclipse.xtext.util.Strings.concat(java.lang.String, java.util.List)
;

String join(String this, String strings) :
    strings
;

String join(String this, Void strings) :
    ''
;
